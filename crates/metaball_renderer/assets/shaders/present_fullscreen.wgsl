// Copied from POC present shader (Phase 2).
struct VertexOutput { @builtin(position) position: vec4<f32>, @location(0) uv: vec2<f32>, }
@group(2) @binding(0) var present_tex: texture_2d<f32>;
@group(2) @binding(1) var albedo_tex: texture_2d<f32>;
@group(2) @binding(2) var present_sampler: sampler;
const ISO: f32 = 0.50; const EDGE_BAND: f32 = 1.50; const USE_DERIV_EDGE: bool = true; const BEVEL_PX: f32 = 18.0; const BEVEL_CURVE_EXP: f32 = 1.4; const BEVEL_SECOND_EXP: f32= 1.0; const FLAT_PX: f32 = 42.0; const EDGE_FADE_EXP: f32 = 1.3; const NORMAL_Z: f32 = 0.65; const AMBIENT: f32 = 0.18; const DIFFUSE_INT: f32 = 0.90; const BASE_COLOR: vec3<f32> = vec3<f32>(0.55, 0.58, 0.66); const EDGE_COLOR: vec3<f32> = vec3<f32>(0.45, 0.60, 0.75); const EDGE_MIX: f32 = 0.35; const SPEC_POW: f32 = 48.0; const SPEC_INT: f32 = 0.60; const SPEC_GRAD_SCALE: f32 = 0.10; const FRES_INT: f32 = 0.50; const FRES_POW: f32 = 3.0; const EDGE_MIX_CURVE: f32  = EDGE_MIX; const BEVEL_HIGHLIGHT_COLOR: vec3<f32> = vec3<f32>(0.95,0.96,0.98); const BEVEL_HIGHLIGHT_INT: f32 = 0.40; const BEVEL_HIGHLIGHT_WIDTH: f32 = 0.80; const BEVEL_HIGHLIGHT_EXP: f32 = 1.2; const SHADOW_OFF: vec2<f32> = vec2<f32>(0.006, -0.009); const SHADOW_SOFT: f32 = 1.0; const SHADOW_INT: f32 = 0.90; const BG_SHADOW_FACTOR: f32 = 0.30; const BG_TOP: vec3<f32> = vec3<f32>(0.08,0.09,0.12); const BG_BOT: vec3<f32> = vec3<f32>(0.03,0.035,0.06); const LIGHT_DIR_UNNORM: vec3<f32> = vec3<f32>(-0.6,0.5,1.0);
fn lerp(a: vec3<f32>, b: vec3<f32>, t: f32) -> vec3<f32> { return a * (1.0 - t) + b * t; }
fn sample_packed(uv: vec2<f32>) -> vec4<f32> { return textureSampleLevel(present_tex, present_sampler, uv, 0.0); }
fn sample_albedo(uv: vec2<f32>) -> vec4<f32> { return textureSampleLevel(albedo_tex, present_sampler, uv, 0.0); }
fn approx_sd(field: f32, iso: f32, inv_grad_len: f32) -> f32 { if (inv_grad_len <= 0.0) { return 0.0; } return (field - iso) * inv_grad_len; }
fn bevel_t(sd_px: f32) -> f32 { var t = clamp(sd_px / BEVEL_PX, 0.0, 1.0); if (BEVEL_SECOND_EXP != 1.0) { t = pow(t, BEVEL_SECOND_EXP); } return pow(t, BEVEL_CURVE_EXP); }
fn fresnel(dot_nv: f32) -> f32 { return pow(1.0 - max(dot_nv, 0.0), FRES_POW) * FRES_INT; }
@fragment fn fragment(v: VertexOutput) -> @location(0) vec4<f32> {
	let uv = v.uv; let dims = vec2<f32>(f32(textureDimensions(present_tex, 0).x), f32(textureDimensions(present_tex, 0).y)); var sample_uv = uv; let aspect = dims.x / dims.y; if (aspect > 1.0) { let scale = aspect; sample_uv.y = (uv.y - 0.5) * scale + 0.5; } else if (aspect < 1.0) { let scale = 1.0 / aspect; sample_uv.x = (uv.x - 0.5) * scale + 0.5; }
	let bg = lerp(BG_BOT, BG_TOP, clamp(uv.y, 0.0, 1.0)); let packed = sample_packed(sample_uv); let field = packed.r; let ngrad = vec2<f32>(packed.g, packed.b); let inv_grad_len = packed.a; var w = 1e-4; if (USE_DERIV_EDGE) { w = max(fwidth(field) * EDGE_BAND, 1e-4); } else { let est = inv_grad_len * 0.5; w = clamp(est, 0.001, 0.05); } let inside_mask = smoothstep(ISO - w, ISO + w, field); let sd = approx_sd(field, ISO, inv_grad_len); let sd_px = sd * dims.x; let t_bevel = bevel_t(min(sd_px, BEVEL_PX)); var edge_factor = 0.0; if (FLAT_PX > BEVEL_PX) { let x = clamp(1.0 - (sd_px - BEVEL_PX) / max(FLAT_PX - BEVEL_PX, 1e-4), 0.0, 1.0); edge_factor = pow(x, EDGE_FADE_EXP); } else { edge_factor = pow(1.0 - t_bevel, EDGE_FADE_EXP); } let rawN = normalize(vec3<f32>(-ngrad.x, -ngrad.y, NORMAL_Z)); let flatN = vec3<f32>(0.0, 0.0, 1.0); var interior_flat_factor = 0.0; if (FLAT_PX > BEVEL_PX) { interior_flat_factor = clamp((sd_px - BEVEL_PX) / max(FLAT_PX - BEVEL_PX, 1e-4), 0.0, 1.0); } let N = normalize(mix(rawN, flatN, interior_flat_factor)); let L = normalize(LIGHT_DIR_UNNORM); let V = vec3<f32>(0.0, 0.0, 1.0); let H = normalize(L + V); let ndl = max(dot(N, L), 0.0); let diffuse = ndl * DIFFUSE_INT; var grad_len = 0.0; if (inv_grad_len > 0.0) { grad_len = 1.0 / inv_grad_len; } let spec_scale = clamp(grad_len * SPEC_GRAD_SCALE, 0.0, 1.0) * edge_factor; let spec = pow(max(dot(N, H), 0.0), SPEC_POW) * SPEC_INT * spec_scale; let fr = fresnel(dot(N, V)) * edge_factor; let edge_tint_mix = (1.0 - t_bevel) * edge_factor; var base_col = lerp(BASE_COLOR, EDGE_COLOR, edge_tint_mix * EDGE_MIX_CURVE); var highlight_w = 0.0; if (sd_px <= BEVEL_PX * BEVEL_HIGHLIGHT_WIDTH) { let h = 1.0 - clamp(sd_px / max(BEVEL_PX * BEVEL_HIGHLIGHT_WIDTH, 1e-4), 0.0, 1.0); highlight_w = pow(h, BEVEL_HIGHLIGHT_EXP) * edge_factor; } base_col = mix(base_col, BEVEL_HIGHLIGHT_COLOR, highlight_w * BEVEL_HIGHLIGHT_INT); var blob_rgb = base_col * (AMBIENT + diffuse) + spec + fr; let albedo = sample_albedo(sample_uv); if (albedo.a > 0.001) { let recovered = albedo.rgb / max(albedo.a, 1e-6); blob_rgb = recovered * (AMBIENT + diffuse) + spec + fr; } let sh_uv0 = sample_uv + SHADOW_OFF * 0.5; let sh_uv1 = sample_uv + SHADOW_OFF * (1.0 + SHADOW_SOFT); let sh_uv2 = sample_uv + SHADOW_OFF * (1.5 + 2.0 * SHADOW_SOFT); let sh0 = smoothstep(ISO - w, ISO + w, sample_packed(sh_uv0).r); let sh1 = smoothstep(ISO - w, ISO + w, sample_packed(sh_uv1).r); let sh2 = smoothstep(ISO - w, ISO + w, sample_packed(sh_uv2).r); let shadow = (sh0 + sh1 + sh2) / 3.0; let bg_shadowed = lerp(bg, bg * BG_SHADOW_FACTOR, clamp(shadow * SHADOW_INT, 0.0, 1.0)); var out_rgb = bg_shadowed; out_rgb = lerp(out_rgb, blob_rgb, inside_mask); return vec4<f32>(out_rgb, 1.0); }
